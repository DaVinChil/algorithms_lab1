# Search algorithms research
Было протестировано три алгоритма поиска:

1. *Бинарный поиск по каждой строке матрицы.*
2. *Лестничный поиск*
3. *Лестничный но с экспоненциальным поиском по горизонтали*

Тесты проводились на матрице M x N. M = 2^x, N = 2^13. 
Формировалась матрица двумя способами:

1. A[i][j] = (N / M * i + j) * 2
2. A[i][j] = (N / M * i * j) * 2

## Запуск
- Java 21
- Java FX 1
1. Скачать java https://www.oracle.com/cis/java/technologies/downloads/.
2. Скачать java fx https://gluonhq.com/products/javafx/
3. Склонировать репозиторий. 
   ```git
    git clone <link>
    ```
4. Пройти в папку с кодом.
    ```cmd
    cd algorithms_lab1/src/main/java
    ```
5. Скомпилировать программу.
    ```cmd 
    javac --module-path "path to java fx lib folder" --add-modules javafx.controls,javafx.fxml -jar ru/ns/alg_lab/*
    ```
6. Запустить программу.
    ```cmd 
    javac --module-path "Path to java fx lib folder" --add-modules javafx.controls,javafx.fxml ru/ns/alg_lab/Main <gen_type>
    ```
   get_type - Способ генерации входных данных (1 или 2)

## Способ 1
При генерации таблицы по первой формуле A[i][j] = (N / M * i + j) * 2. В общем картина выглядит так.
![first_chart_overall](first_approach_overall.png)
Как можно заметить при увеличении данных бинарный поиск сильно отстает. Так же при увеличении таблица становится более квадратной, за счет чего экспоненциальному поиску приходиться вызывать поиск по горизонтале все чаще и чаще, поэтому обычный ладдер его обганяет.
Не смотря на то что при малых данных экспоненциальный поиск должен быть быстрее, как мы видим он отстает, скорее всего из за погрешности низкоуровневых операций.
![first_chart_closer](first_approach_closer.png)
## Способ 2
При втором способе картина относительно бинарного поиска мало чем отличается. Однако ладдер и экспоненциальный идут вместе. Так как искомый элемент больше любого элемента в массиве, при поиске мы постоянно смещаемся вниз и экспоненциальный поиск по горизонтали не вызывается, что делает их индентичными.
![second_chart_overall](second_approach_overall.png)
На малых данных результаты не отличается  от первого способа.
![second_chart_closer](second_approach_closer.png)